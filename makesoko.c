/*++

Copyright (c) 2010 Evan Green

Module Name:

    makesoko.c

Abstract:

    This module implements the program responsible for creating the sokodat.c
    source file with the Sokoban data.

Author:

    Evan Green 14-Nov-2010

Environment:

    Build

--*/

//
// ------------------------------------------------------------------- Includes
//

#include "types.h"
#include "sokoban.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// ---------------------------------------------------------------- Definitions
//

#define USAGE_STRING \
    "MakeSoko takes in a level map and creates a output C file containing a " \
    "packed array of those levels.\n\n" \
    "Usage: MakeSoko [-o <OutputFile>] <InputFile>\n\n"

#define OUTPUT_BOILERPLATE \
    "/*++\n\n" \
    "Copyright (c) 2010 Evan Green\n\n" \
    "Module Name:\n\n" \
    "    sokodata.c\n\n" \
    "Abstract:\n\n" \
    "    This module contains the packed Sokoban level information.\n" \
    "    WARNING: THIS FILE IS AUTOGENERATED. DO NOT ALTER OR CHECK IN " \
    "DIRECTLY!!\n\n" \
    "Author:\n\n" \
    "    Evan Green 14-Nov-2010\n\n"\
    "Environment:\n\n" \
    "    x86/AVR\n\n" \
    "--*/\n\n" \
    "//\n" \
    "// -----------------------------------------------------------------" \
    "-- Includes\n" \
    "//\n\n" \
    "#include \"types.h\"\n" \
    "#include \"sokoban.h\"\n\n" \
    "//\n" \
    "// ------------------------------------------------------------------" \
    "-- Globals\n" \
    "//\n\n" \

#define SOKOBAN_DATA_VARIABLE \
    "const UCHAR SokobanData[SOKOBAN_LEVELS][SOKOBAN_LEVEL_SIZE] PROGMEM = {\n"

#define SOKOBAN_ORIGIN_VARIABLE \
    "const USHORT SokobanStartingPosition[SOKOBAN_LEVELS] PROGMEM = {"

#define SOKOBAN_LEVEL_BEGIN "    {"
#define SOKOBAN_DATA_BEGIN "\n        "
#define SOKOBAN_LEVEL_END "\n    },\n"
#define SOKOBAN_ORIGIN_BEGIN "\n    "
#define SOKOBAN_VARIABLE_END "};\n\n"

//
// ------------------------------------------------------ Data Type Definitions
//

typedef unsigned char BOOL;

//
// ----------------------------------------------- Internal Function Prototypes
//

BOOL
MemoryMapFile (
    PCHAR Filename,
    PUCHAR *Buffer,
    PULONG FileSize
    );

LONG
GetFileSize (
    FILE *File
    );

BOOL
CreateSokobanData (
    PCHAR Input,
    ULONG InputSize,
    FILE *OutputFile
    );

//
// -------------------------------------------------------------------- Globals
//

//
// Define a global containing the packed level maps.
//

UCHAR GeneratedSokobanData[SOKOBAN_LEVELS][SOKOBAN_LEVEL_SIZE];

//
// Define a global containing the initial user starting position.
//

USHORT GeneratedSokobanStartingPosition[SOKOBAN_LEVELS];

//
// ------------------------------------------------------------------ Functions
//

INT
main (
    INT argc,
    CHAR **argv
    )

/*++

Routine Description:

    This routine is the main entry point for the program. It collects the
    options passed to it, and creates the output file.

Arguments:

    argc - Supplies the number of command line arguments the program was invoked
           with.

    argv - Supplies a tokenized array of command line arguments.

Return Value:

    Returns an integer exit code. 0 for success, nonzero otherwise.

--*/

{

    PCHAR Argument;
    PUCHAR InputFile;
    ULONG InputFileSize;
    PCHAR InputImage;
    FILE *OutputFile;
    PCHAR OutputImage;
    BOOL Result;

    //
    // Process the command line options
    //

    InputImage = NULL;
    OutputImage = NULL;
    while ((argc > 1) && (argv[1][0] == '-')) {
        Argument = &(argv[1][1]);
        if (strcmp(Argument, "o") == 0) {
            argc -= 1;
            argv += 1;
            OutputImage = argv[1];

        } else {
            fprintf(stderr, "%s: Invalid option\n\n%s", Argument, USAGE_STRING);
            return 1;
        }

        argc -= 1;
        argv += 1;
    }

    InputImage = argv[1];
    if ((argc < 2) || (InputImage == NULL) || (OutputImage == NULL)) {
        fprintf(stderr, USAGE_STRING);
        return 1;
    }

    //
    // Start by opening the output file.
    //

    OutputFile = fopen(OutputImage, "wb+");
    if (OutputFile == NULL) {
        fprintf(stderr, "Unable to open output file \"%s\" for write.\n",
                OutputImage);

        Result = FALSE;
        goto MainEnd;
    }

    Result = MemoryMapFile(InputImage, &InputFile, &InputFileSize);
    if (Result == FALSE) {
        fprintf(stderr, "Error: Unable to memory map input file.\n");
        goto MainEnd;
    }

    Result = CreateSokobanData(InputFile, InputFileSize, OutputFile);
    if (Result == FALSE) {
        fprintf(stderr, "Error creating data.\n");
        goto MainEnd;
    }

    Result = TRUE;

MainEnd:
    if (InputFile != NULL) {
        free(InputFile);
    }

    if (OutputFile != NULL) {
        fclose(OutputFile);
    }

    if (Result == FALSE) {
        return 1;
    }

    return 0;
}

//
// --------------------------------------------------------- Internal Functions
//

BOOL
CreateSokobanData (
    PCHAR Input,
    ULONG InputSize,
    FILE *OutputFile
    )

/*++

Routine Description:

    This routine creates the sokoban data given a level map.

Arguments:

    Input - Supplies a pointer to a string containing the level maps.

    InputSize - Supplies the size, in byes, of the input, including the NULL
        terminator.

    OutputFile - Supplies an open file handle where the result is to be printed.

Return Value:

    TRUE on success.

    FALSE on failure.

--*/

{

    ULONG BytesRead;
    ULONG BytesWritten;
    UCHAR Character;
    ULONG CurrentByte;
    ULONG CurrentCell;
    UCHAR CurrentLevel;
    CHAR DataString[10];
    BOOL EmptyLine;
    BOOL Result;
    UCHAR ThisCell;

    //
    // Print out the boilerplate.
    //

    BytesWritten = fwrite(OUTPUT_BOILERPLATE,
                          1,
                          strlen(OUTPUT_BOILERPLATE),
                          OutputFile);

    if (BytesWritten != strlen(OUTPUT_BOILERPLATE)) {
        fprintf(stderr, "Error: Unable to print boilerplate.\n");
        Result = FALSE;
        goto CreateSokobanDataEnd;
    }

    //
    // Consume the input file and create the data.
    //

    BytesRead = 0;
    EmptyLine = TRUE;
    CurrentCell = 0;
    CurrentLevel = 0;
    while (BytesRead < InputSize) {
        Character = *Input;
        BytesRead += 1;
        Input += 1;

        //
        // Ignore comments.
        //

        if (Character == ';') {
            while (Character != '\n') {
                Character = *Input;
                BytesRead += 1;
                Input += 1;
            }

            EmptyLine = TRUE;
            continue;
        }

        //
        // Ignore \r characters.
        //

        if (Character == '\r') {
            continue;
        }

        //
        // Handle an object such as a free space, wall, bean, or goal.
        //

        if ((Character == ' ') ||
            (Character == '#') ||
            (Character == '.') ||
            (Character == '$') ||
            (Character == '@')) {

            EmptyLine = FALSE;
            ThisCell = 0;
            if ((Character == ' ') || (Character == '@')) {
                ThisCell = SOKOBAN_CELL_FREE;
            }

            if (Character == '#') {
                ThisCell = SOKOBAN_CELL_WALL;
            }

            if (Character == '$') {
                ThisCell = SOKOBAN_CELL_BEAN;
            }

            if (Character == '.') {
                ThisCell = SOKOBAN_CELL_GOAL;
            }

            if (CurrentCell >= (SOKOBAN_HEIGHT * SOKOBAN_WIDTH)) {
                fprintf(stderr,
                        "Error: Level %d is too large, doesn't fit in %dx%d!\n",
                        CurrentLevel,
                        SOKOBAN_WIDTH,
                        SOKOBAN_HEIGHT);

                Result = FALSE;
                goto CreateSokobanDataEnd;
            }

            if (CurrentLevel >= SOKOBAN_LEVELS) {
                fprintf(stderr,
                        "Warning: Ignoring levels after %d.\n",
                        SOKOBAN_LEVELS);

                Result = TRUE;
                goto CreateSokobanDataEnd;
            }

            GeneratedSokobanData[CurrentLevel][CurrentCell / 4] |=
                                            ThisCell << (2 * (CurrentCell % 4));

            //
            // Handle an origin.
            //

            if (Character == '@') {
                GeneratedSokobanStartingPosition[CurrentLevel] =
                       (CurrentCell / SOKOBAN_WIDTH) << SOKOBAN_ORIGIN_Y_SHIFT;

                GeneratedSokobanStartingPosition[CurrentLevel] |=
                                                   CurrentCell % SOKOBAN_WIDTH;
            }

            CurrentCell += 1;
        }

        //
        // Handle a newline. A newline completely by itself signals a new level.
        // Otherwise, it signals that the rest of the cells on this line are
        // filled with blanks.
        //

        if (Character == '\n') {

            //
            // Ignore the newline if no cells have been defined for this level.
            //

            if (CurrentCell == 0) {
                EmptyLine = TRUE;
                continue;
            }

            //
            // Round up the current cell to a multiple of the game width.
            //

            while ((CurrentCell % SOKOBAN_WIDTH) != 0) {
                CurrentCell += 1;
            }

            //
            // If this was an empty line, start a new level.
            //

            if (EmptyLine != FALSE) {
                CurrentLevel += 1;
                CurrentCell = 0;
            }

            EmptyLine = TRUE;
        }
    }

    //
    // Output the level data.
    //

    BytesWritten = fwrite(SOKOBAN_DATA_VARIABLE,
                          1,
                          strlen(SOKOBAN_DATA_VARIABLE),
                          OutputFile);

    if (BytesWritten != strlen(SOKOBAN_DATA_VARIABLE)) {
        fprintf(stderr, "Error: Unable to data variable header.\n");
        Result = FALSE;
        goto CreateSokobanDataEnd;
    }

    //
    // Output each level's data.
    //

    for (CurrentLevel = 0; CurrentLevel < SOKOBAN_LEVELS; CurrentLevel += 1) {
        BytesWritten = fwrite(SOKOBAN_LEVEL_BEGIN,
                              1,
                              strlen(SOKOBAN_LEVEL_BEGIN),
                              OutputFile);

        if (BytesWritten != strlen(SOKOBAN_LEVEL_BEGIN)) {
            fprintf(stderr, "Error: Unable to write level beginning.\n");
            Result = FALSE;
            goto CreateSokobanDataEnd;
        }

        //
        // Output each byte of data.
        //

        for (CurrentByte = 0;
             CurrentByte < SOKOBAN_LEVEL_SIZE;
             CurrentByte += 1) {

            if ((CurrentByte % 12) == 0) {
                BytesWritten = fwrite(SOKOBAN_DATA_BEGIN,
                                      1,
                                      strlen(SOKOBAN_DATA_BEGIN),
                                      OutputFile);

                if (BytesWritten != strlen(SOKOBAN_DATA_BEGIN)) {
                    fprintf(stderr, "Error: Unable to write line beginning.\n");
                    Result = FALSE;
                    goto CreateSokobanDataEnd;
                }
            }

            sprintf(DataString,
                    "0x%02x, ",
                    GeneratedSokobanData[CurrentLevel][CurrentByte]);

            BytesWritten = fwrite(DataString,
                                  1,
                                  strlen(DataString),
                                  OutputFile);

            if (BytesWritten != strlen(DataString)) {
                fprintf(stderr, "Error: Unable to write data.\n");
                Result = FALSE;
                goto CreateSokobanDataEnd;
            }
        }

        //
        // Output a closing curly brace at the end of each level.
        //

        BytesWritten = fwrite(SOKOBAN_LEVEL_END,
                              1,
                              strlen(SOKOBAN_LEVEL_END),
                              OutputFile);

        if (BytesWritten != strlen(SOKOBAN_LEVEL_END)) {
            fprintf(stderr, "Error: Unable to level ending.\n");
            Result = FALSE;
            goto CreateSokobanDataEnd;
        }
    }

    //
    // Finish off the variable.
    //

    BytesWritten = fwrite(SOKOBAN_VARIABLE_END,
                          1,
                          strlen(SOKOBAN_VARIABLE_END),
                          OutputFile);

    if (BytesWritten != strlen(SOKOBAN_VARIABLE_END)) {
        fprintf(stderr, "Error: Unable to write variable ending.\n");
        Result = FALSE;
        goto CreateSokobanDataEnd;
    }

    //
    // Output the origins.
    //

    BytesWritten = fwrite(SOKOBAN_ORIGIN_VARIABLE,
                          1,
                          strlen(SOKOBAN_ORIGIN_VARIABLE),
                          OutputFile);

    if (BytesWritten != strlen(SOKOBAN_ORIGIN_VARIABLE)) {
        fprintf(stderr, "Error: Unable to origin variable header.\n");
        Result = FALSE;
        goto CreateSokobanDataEnd;
    }

    //
    // Output each entry of the origins.
    //

    for (CurrentLevel = 0; CurrentLevel < SOKOBAN_LEVELS; CurrentLevel += 1) {
        if ((CurrentLevel % 8) == 0) {
            BytesWritten = fwrite(SOKOBAN_ORIGIN_BEGIN,
                                  1,
                                  strlen(SOKOBAN_ORIGIN_BEGIN),
                                  OutputFile);

            if (BytesWritten != strlen(SOKOBAN_ORIGIN_BEGIN)) {
                fprintf(stderr, "Error: Unable to origin line begin.\n");
                Result = FALSE;
                goto CreateSokobanDataEnd;
            }
        }

        sprintf(DataString,
                "0x%04x, ",
                GeneratedSokobanStartingPosition[CurrentLevel]);

        BytesWritten = fwrite(DataString,
                              1,
                              strlen(DataString),
                              OutputFile);

        if (BytesWritten != strlen(DataString)) {
            fprintf(stderr, "Error: Unable to write origin data.\n");
            Result = FALSE;
            goto CreateSokobanDataEnd;
        }

    }

    //
    // Close off the origin variable.
    //

    BytesWritten = fwrite(SOKOBAN_VARIABLE_END,
                          1,
                          strlen(SOKOBAN_VARIABLE_END),
                          OutputFile);

    if (BytesWritten != strlen(SOKOBAN_VARIABLE_END)) {
        fprintf(stderr, "Error: Unable to origin variable end.\n");
        Result = FALSE;
        goto CreateSokobanDataEnd;
    }

    Result = TRUE;

CreateSokobanDataEnd:
    return Result;
}

BOOL
MemoryMapFile (
    PCHAR Filename,
    PUCHAR *Buffer,
    PULONG FileSize
    )

/*++

Routine Description:

    This routine determines the file size in bytes of the given file.

Arguments:

    File - Supplies a handle to the file opened for at least read in binary
        mode.

    Buffer - Supplies a pointer to where the newly allocated buffer will be
        returned. It is the caller's responsibility to free this buffer.

    FileSize - Supplies pointer to the integer that receives the file size.

Return Value:

    Returns the file size in bytes.

--*/

{

    LONG BytesRead;
    FILE *File;
    PUCHAR MappedFile;
    BOOL Result;

    MappedFile = NULL;
    Result = FALSE;

    *Buffer = NULL;
    *FileSize = 0;
    File = fopen(Filename, "rb");
    if (File == NULL) {
        printf("Unable to open file \"%s\" for read.\n", Filename);
        goto MemoryMapFileEnd;

    }

    *FileSize = GetFileSize(File);
    if (*FileSize <= 0) {
        printf("Unable to get file size of file \"%s\"!\n", Filename);
        goto MemoryMapFileEnd;
    }

    MappedFile = malloc(*FileSize);
    if (MappedFile == NULL) {
        goto MemoryMapFileEnd;
    }

    BytesRead = fread(MappedFile, 1, *FileSize, File);
    if (BytesRead != *FileSize) {
        printf("Unable to read %d bytes, actually read %d.\n",
               (INT)*FileSize,
               (INT)BytesRead);

        goto MemoryMapFileEnd;
    }

    Result = TRUE;

MemoryMapFileEnd:
    if (File != NULL) {
        fclose(File);
    }

    if (Result == FALSE) {
        if (MappedFile != NULL) {
            free(MappedFile);
        }

    } else {
        *Buffer = MappedFile;
    }

    return Result;
}

LONG
GetFileSize (
    FILE *File
    )

/*++

Routine Description:

    This routine determines the file size in bytes of the given file.

Arguments:

    File - Supplies a handle to the file opened for at least read in binary
        mode.

Return Value:

    Returns the file size in bytes.

--*/

{

    LONG FileSize;

    fseek(File, 0, SEEK_END);
    FileSize = ftell(File);
    fseek(File, 0, SEEK_SET);
    return FileSize;
}

